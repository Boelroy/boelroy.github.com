<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数组初始化为0体位的性能测试 · Boelroy</title><meta name="description" content="数组初始化为0体位的性能测试 - Boelroy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.boelroy.com/atom.xml" title="Boelroy"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.instagram.com/boelroy/" target="_blank" class="nav-list-link">INSTAGRAM</a></li><li class="nav-list-item"><a href="https://github.com/Boelroy" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">数组初始化为0体位的性能测试</h1><div class="post-info">Feb 25, 2018</div><div class="post-content"><p>数组应该是在JavaScript最常用的数据结构之一，我们有很多种方式来初始化一个数组。但是 JavaScript 怎样把一个数组的所有元素初始化为0 最有效率？为了得出答案，我们做了一下测试：</p>
<p>我们将在 Node 下(Node.js 版本 v8.4.0)初始化一个长度为 100 万的数组，来对比他们的性能。<br><a id="more"></a></p>
<h3 id="不同姿势"><a href="#不同姿势" class="headerlink" title="不同姿势"></a>不同姿势</h3><h5 id="姿势-1"><a href="#姿势-1" class="headerlink" title="姿势 1:"></a>姿势 1:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">sizeofArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sizeofArray; i++) &#123;</span><br><span class="line">        result[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本 1 是我们最常见的做法，先声明一个空数组变量，然后用一个 for 初始化数组的每一位。</p>
<blockquote>
<p>未预热: 一次 245<br>预热: 平均 261.9<br>预热: 总共 23571</p>
</blockquote>
<h5 id="姿势-2"><a href="#姿势-2" class="headerlink" title="姿势 2:"></a>姿势 2:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">sizeofArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sizeofArray; i++) &#123;</span><br><span class="line">        result.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本 2 中我们在版本 1 中的 for 循环的下标赋值变成了数组api push。</p>
<blockquote>
<p>未预热: 一次 282<br>预热: 总共 25233<br>预热: 平均 280.3666666666667</p>
</blockquote>
<h5 id="姿势-3"><a href="#姿势-3" class="headerlink" title="姿势 3:"></a>姿势 3:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">sizeofArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>(sizeofArray);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; sizeofArray; i++) &#123;</span><br><span class="line">        result[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本 3 中 首先我们先定义Array的大小 然后通过下标进行赋值</p>
<blockquote>
<p>未预热: 一次 61<br>预热: 总共 5048<br>预热: 平均 56.08888888888889</p>
</blockquote>
<h5 id="姿势-4"><a href="#姿势-4" class="headerlink" title="姿势 4:"></a>姿势 4:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">sizeofArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Array</span>(sizeofArray).fill(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本 4 中 首先定义了 Array 的大小，然后通过 fill 进行初始化</p>
<blockquote>
<p>未预热: 一次 250<br>预热: 平均 59.422222222222224<br>预热: 总共 5348</p>
</blockquote>
<h5 id="姿势-5"><a href="#姿势-5" class="headerlink" title="姿势 5:"></a>姿势 5:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">sizeofArray</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [];</span><br><span class="line">    [].length = sizeofArray;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; sizeofArray) &#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本 6 首先定义一定一个长度为0的数组变量，然后赋值给 length 为要初始化的大小，最后用循环初始化每一个数。</p>
<blockquote>
<p>未预热: 一次 57<br>预热: 平均 61.355555555555554<br>预热: 总共 5522</p>
</blockquote>
<h5 id="姿势-6"><a href="#姿势-6" class="headerlink" title="姿势 6:"></a>姿势 6:</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">sizeofArray</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.slice.apply(<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(sizeofArray));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异类 版本5 我们先定义固定大小的 Uint8Array, 这个Type Array 会首先都初始化为0 之后调用Array原型中的slice将其转化为数组</p>
<blockquote>
<p>未预热: 一次 1276<br>预热: 平均 913.7111111111111<br>预热: 总共 82234</p>
</blockquote>
<h3 id="结果对比"><a href="#结果对比" class="headerlink" title="结果对比"></a>结果对比</h3><p>具体的结果如下所示，我们可以看到一些很有趣的结果。由于 Version 1 是我们在日常变成中最常见的版本，所以我们以 Version 1 为标准对比其他的版本。</p>
<p><a href="/assets/pics/array-performance-chart.png"><img src="/assets/pics/array-performance-chart.png" alt="array-init-performance"></a></p>
<p>首先我们可以看到 Version 2 和 Version 1 相比并没有太大的差距，所以我们认为 Version 2 几乎与 Version 1 的写法等价。带来的稍微增多的时间可能是对 push 函数内部的调用所带来的。</p>
<p>而 Version 3 和 Version 1 相比带了了四倍左右的性能提升。而写法上的改变仅仅是因为在初始化的时候发生了改变，即 <code>let arr = []</code>（或者写成）<code>let arr = Array()</code> 变成了 <code>let arr = Array(size)</code>。为啥这个小小的改变能够带来如此的性能提升呢（问题一）？如果具有 C 或者 C++ 背景的的同学应该会找到一点头绪。</p>
<p>Version 3 和 Version 5 基本等价。</p>
<p>对于 Version 4 中在第一次运行的过程中和 Version 1 保持了差不多的性能，但是在运行了多次之后平均的时间变快了。我们知道 JIT 会对运行的代码进行优化，应该是 Version 4被 JIT 优化了。</p>
<p>最后当然最慢的是逗逼的 Version 6, 其实这个在性能上的损失是显而易见的，Uint8Array 通过 slice 发生了数据转换。从 TypeArray 转换到了 Array, 而且 0 在 Array 中是一个 64 位双精度二进制的值，而 Uint8Array 中 0 是一个无符号的 8 位整数。</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>通过上面的分析，我们总结一下遇到的问题。</p>
<ol>
<li><code>let arr = []</code>（或者写成）<code>let arr = new Array()</code> 变成了 <code>let arr = new Array(size)</code>。这个小小的改变能够带来如此的性能提升呢。</li>
<li><code>arr.length = size</code> 发生了什么</li>
</ol>
<h3 id="到底发生了什么？"><a href="#到底发生了什么？" class="headerlink" title="到底发生了什么？"></a>到底发生了什么？</h3><p>要回答上面的问题要如何下手呢？首先我们先要弄清楚数组在构造, 下标赋值，push, fill, slice 的时候干了什么事情。</p>
<h4 id="ECMA-Spec"><a href="#ECMA-Spec" class="headerlink" title="ECMA Spec"></a>ECMA Spec</h4><p>要具体了解发生了什么事情，我们只能去翻一翻 ECMA 标准中是如何规定这些操作的行为的。具体的可以参阅 </p>
<p>1.<a href="http://lzw.me/pages/ecmascript/#336" target="_blank" rel="noopener">Array 构造</a></p>
<p>2.<a href="http://lzw.me/pages/ecmascript/#366" target="_blank" rel="noopener">Array的下标赋值描述如下</a></p>
<p>3.Array <a href="https://www.ecma-international.org/ecma-262/7.0/#sec-array.prototype.fill" target="_blank" rel="noopener">fill</a> and <a href="http://lzw.me/pages/ecmascript/#349" target="_blank" rel="noopener">push</a></p>
<p>根据 ECMA 标准，Array 初始的时候<code>let arr = []</code>（或者）<code>let arr = new Array()</code> 与 <code>let arr = new Array(size)</code>没有本质的区别，只是后者的数组实例的 length 的 赋值为 size。但是在写入数组的过程中，我们发现 Version 1 会频繁的修改数组实例的 length 属性，这样势必会带来性能的损失。当然根据经验，这点频繁的修改在实际的过程中可能并不会带来多少的性能损失。那么到底哪里出问题了呢？</p>
<h4 id="没办法只能看内存了"><a href="#没办法只能看内存了" class="headerlink" title="没办法只能看内存了"></a>没办法只能看内存了</h4><p>所以我们只能从别的方面来想办法。如果有其他语言编程背景，应该会猜测对于 Version 1 在插入的时候可能会频繁的出现数组长度不够，需要扩展的时候。那么我们猜测是频繁的内存分配导致了性能的损失。但是根据上面的 ECMA 的标准，其中并没有说明是否当时应该给分类内存，初始化的不同仅仅是 length 的不一样。所以并不能确定这一点，有可能 Version 3 也并没有分配内存，也需要发生频繁的内存分配（当然，JavaScript 的 Runtime 不会像我这么傻）。如何确定呢？</p>
<p>所以我们还需要跟准确的分析。所以我们在 Chrome DevTool 分别运行两段代码，在 Performance 的比较如下所示。很明显的看到 Version 1 多发生了两次的 Minor GC。 这就是性能损失的原因。Version 1 中可能初始的内存池比较小，在为数组开辟空间的时候，发生了频繁的内存分配，并且当无法分配的时候就会发生 GC。而 Version 3 预先的为数组留够了空间，从而不会再写入的过程中发生 GC。</p>
<p><a href="/assets/pics/array-init-gc.png"><img src="/assets/pics/array-init-gc.png" alt="array-init-performance"></a></p>
<h4 id="是时候回答问题了"><a href="#是时候回答问题了" class="headerlink" title="是时候回答问题了"></a>是时候回答问题了</h4><p>通过上面的分析我们可以回答问题1. 性能的损失主要是在内存的频繁分配和 GC 上。</p>
<p>而问题2 根据 ECMA Spec 很容易的出来。<code>arr.length = size</code> 在 spec 中只是改变了 length 大小。不过如果 size &lt; length, 会删除 size 之后的元素。如果 size &gt; length, 则会形成一个空洞数组(hole).这个新的 size 会告诉 runtime 预留出空间来。</p>
<h4 id="最正确初始化姿势"><a href="#最正确初始化姿势" class="headerlink" title="最正确初始化姿势"></a>最正确初始化姿势</h4><p>通过上面的分析我们可以看到如果你要操作大数组，那么最好是预留出空间来。lodosh 的 map 好像就是这么做的。不过通过版本4 可以看到，JIT 经过预热后性能也是最理想的，而且代码长度和可读性也是里面最好的一个版本。</p>
<p>所以自然如果是 es6 的环境下 <code>new Array(sizeofArray).fill(0);</code> 是初始化的最好选择。</p>
<p>当然这个上面都是突发奇想来探究这个问题，优化在点滴，但是又常说不要过早优化。这篇文章就当做提供一个思路来分析我们工作遇到的问题。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/10/15/javascript/介绍/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://blog.boelroy.com">Boelroy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41473417-2",'auto');ga('send','pageview');</script></body></html>