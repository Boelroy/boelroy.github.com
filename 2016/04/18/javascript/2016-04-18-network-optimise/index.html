<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 那些前端优化技术背后的原理1 · Boelroy</title><meta name="description" content="那些前端优化技术背后的原理1 - Boelroy"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://blog.boelroy.com/atom.xml" title="Boelroy"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.instagram.com/boelroy/" target="_blank" class="nav-list-link">INSTAGRAM</a></li><li class="nav-list-item"><a href="https://github.com/Boelroy" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">那些前端优化技术背后的原理1</h1><div class="post-info">Apr 18, 2016</div><div class="post-content"><h3 id=""><a href="#" class="headerlink" title=""></a><a href="/pics/Speed-up.png"><img src="/pics/Speed-up.png" alt="speed-up"></a></h3><p>现在我们在开发一个网页的时候有很多的优化的最佳实践，诸如将Javascript放在文档的底部。很多时候我们已经将这个最佳实践当成了习惯，其实探究这些方法背后的原理还是挺好玩的一件事。当然在这里Google给出了很详细的文章<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=en" target="_blank" rel="noopener">说明</a></p>
<p>前端页面的优化其实需要从很多地方来考虑，但是优化的基础就是先弄清楚浏览器是如何展现一个页面的。明白了整个过程，当然知道了性能的瓶颈在哪里，当然也自然知道该如何针对性的去优化。</p>
<h2 id="Critical-Rendering-Path"><a href="#Critical-Rendering-Path" class="headerlink" title="Critical Rendering Path"></a>Critical Rendering Path</h2><p>当然<code>当你在浏览器中按下回车键到页面展现的整个过程</code>是一个很远古的面试问题，这个 <a href="https://github.com/alex/what-happens-when" target="_blank" rel="noopener">github repo</a> 很清楚而且详细的探究了整个过程。这里重点强调一下整个页面渲染的过程。<br><a id="more"></a></p>
<h4 id="得到DOM树"><a href="#得到DOM树" class="headerlink" title="得到DOM树"></a>得到DOM树</h4><p>当浏览器获得了请求的HTML之后，会先干一件事情，就是将整个HTML解析成DOM树。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以上面的HTML会被解析成如下的结构</p>
<p><a href="/pics/dom-tree.png"><img src="/pics/dom-tree.png" alt="dom-tree"></a></p>
<p>这里说明一下DOM，当然学JavaScript的人都知道DOM是文档对象模型，他本是是对XML的一个通用的变成接口，但是经过扩展之后就能用于HTML，提供了对HTML删除，添加替换和修改的api。其本身只是一个通用的规范。在这个规范中其实<code>并没有</code>指定文档的结构必须是一个树形的。当然树形结构有他本身的优势，所以基本上所有的说法都会用到 DOM tree 这个词。这里是<a href="https://www.w3.org/TR/DOM-Level-2-Core/introduction.html" target="_blank" rel="noopener">DOM</a>的定义。</p>
<p>整个解析成DOM树的过程需要消耗一定的时间，尤其是在处理大量的HTML的时候。</p>
<h4 id="得到CCSOM树"><a href="#得到CCSOM树" class="headerlink" title="得到CCSOM树"></a>得到CCSOM树</h4><p>当浏览器解析了HTML之后，发现了一个stylesheet的标签，所以浏览器立刻发出一个请求，获取test.css的内容</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">font-size</span>: <span class="number">16px</span> &#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">font-weight</span>: bold &#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; <span class="attribute">color</span>: red &#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; <span class="attribute">display</span>: none &#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; <span class="attribute">float</span>: right &#125;</span><br></pre></td></tr></table></figure>
<p>在获取到css之后，和HTML一样，浏览器会做将css解析成一种结构，这里称为CCSOM，CSS对象模型。具体解析如下：</p>
<p><a href="/pics/cssom-tree.png"><img src="/pics/cssom-tree.png" alt="cssom-tree"></a></p>
<p>当然这里我们假设一个HTML中没有样式存在，那么是不是可以跳过这个过程呢？答案是否定的，我们都知道浏览器会有默认样式，所以默认样式也会被构建成CCSOM。当然考虑到这些，我们也就知道上图中的树其实是不完整的。</p>
<h4 id="得到渲染树"><a href="#得到渲染树" class="headerlink" title="得到渲染树"></a>得到渲染树</h4><p>当我们得到了DOM树和CCSOM树之后，我们就能将这两棵树合并成一棵渲染树。这里的渲染树包含了页面上所有的可视元素和这些元素的样式信息。</p>
<p>这里创建的过程大概如下所示:</p>
<blockquote>
<p>1.从DOM树的根节点开始遍历所有的可视节点。</p>
<p>—-有些不可见的元素(如脚本标签，元数据标签之类的)会被忽略，因为他们不影响页面的渲染结果</p>
<p>—-有些css隐藏掉的元素也会被忽略。</p>
<p>2.对于每个可视节点，从CSSOM中寻找对应的样式规则，并付诸节点</p>
<p>3.输出可视节点，以及每个节点的样式信息</p>
</blockquote>
<p>下面就是上述HTML的渲染树：</p>
<p><a href="/pics/render-tree-construction.png"><img src="/pics/render-tree-construction.png" alt="render-tree-construction"></a></p>
<h4 id="计算布局和渲染"><a href="#计算布局和渲染" class="headerlink" title="计算布局和渲染"></a>计算布局和渲染</h4><p>在生成了渲染树之后我们就能对页面进行布局了，我们都知道CSS的布局是盒模型，这也是布局阶段最终的输出结果，计算每个元素所占盒子的大小，以及相对于父元素的位置。</p>
<p>最后我们有了这个盒模型之后就能将每一节点渲染成屏幕上的点。这个过程称为“绘制”。</p>
<h4 id="页面渲染关键路径"><a href="#页面渲染关键路径" class="headerlink" title="页面渲染关键路径"></a>页面渲染关键路径</h4><p>所以页面渲染的关键路径也就是上述的步骤：</p>
<blockquote>
<p>1.生成DOM树</p>
<p>2.生成CSSOM树</p>
<p>3.将DOM树和CCSOM树合并成渲染树。</p>
<p>4.对渲染树进行布局，计算每个节点的几何外观</p>
<p>5.将渲染树种的每个节点绘制到屏幕上。</p>
</blockquote>
<p><a href="/pics/crp.png"><img src="/pics/crp.png" alt="crp"></a></p>
<h4 id="Javascript-去哪里了？"><a href="#Javascript-去哪里了？" class="headerlink" title="Javascript 去哪里了？"></a>Javascript 去哪里了？</h4><p>这里我们没有讨论到JavaScript对也页面的影响，假设我们有如下的页面</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>I love <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> <span class="built_in">document</span>.write(<span class="string">'awesome'</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> Javascript <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们会在屏幕上看见什么？可能有的人认为是<code>I love Javascript</code>, 但实际上最后我们在屏幕上看见的是<code>I love awesome Javascript</code>。</p>
<p>为什么会这样？事实上从这个例子我可以看出JavaScript对页面初次渲染产生的影响。</p>
<p>当DOM树构建到<code>scirpt</code>标签的时候，整个解析会停下来，所以这个时候HTML只解析到<code>script</code>标签之前也就是，然后浏览器会执行脚本，然后将awesome写到了整个文档中，最后才将JavaScript加入到DOM树中去。所以JavaScript脚本会阻塞整个页面的渲染，直到脚本执行完毕。</p>
<p>这里我们可以得出结论：内联的JavaScript会阻塞DOM树的构建。</p>
<p>如果我们将Javascript换成外部引用结果会不会不一样呢(如我们用<code>&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;</code>)。答案是No。整个页面的解析依旧会被阻塞，直到我们从外部加载完app.js，然后执行它之后，才会进行后续的解析。</p>
<p>当然这里还没有提到css资源和JavaScript的关系。我们知道JavaScript可以修改一个元素的CSS属性，那么这里就有一个trick的地方，当内联的JavaScript执行的时候需要修改样式表但是还没完成CSSOM的加载和创建会怎么样？答案很简单：JavaScript会被延迟加载，直到它完成了CSSOM的下载和构建，当我们在等待的时候DOM构建也被阻塞了。所以其实当我们在构建DOM的时候如果碰到JavaScript，那么<code>DOM构建要同时等待JS的执行和CSS文件的获取</code>。</p>
<p>下图展示了一个完整的关键渲染路径：</p>
<h2 id="是时候优化了"><a href="#是时候优化了" class="headerlink" title="是时候优化了"></a>是时候优化了</h2><p>经过上面的分析，critical rendering path(CRP) 决定页面的初次显示。所以优化的重点就是在于尽量减小 CRP 的时间。这里还有各一个概念 critical resouce (关键资源)，其实也就是在影响页面初次渲染的资源，如外链的CSS，他会阻塞整个也页面，因为只有加载CSS才能构建CCSOM。这里关键资源包括：HTML，inline CSS, inline JavaSript, extern CSS 和 阻塞的 extern JavaScript(这里说阻塞了表示并非所有JavaScript资源都会阻塞页面的初次渲染)。</p>
<p>所以这里我们可以从三个方面出发：</p>
<blockquote>
<p>1.最小化关键资源的数量</p>
<p>2.最小化关键资源的字节</p>
<p>3.最小化关键路径的长度</p>
</blockquote>
<h4 id="Minify-Compress-Cache"><a href="#Minify-Compress-Cache" class="headerlink" title="Minify, Compress, Cache"></a>Minify, Compress, Cache</h4><p>对HTML，CSS，JavaScript 文件进行压缩、缓存，可以减小获取文件的传输时间这也是最小化关键资源的字节。</p>
<h4 id="Inline-CSS"><a href="#Inline-CSS" class="headerlink" title="Inline CSS"></a>Inline CSS</h4><p>这里我们可以将CSS嵌入在HTML中，这样我们可以减少对外部CSS获取时间，这样也能更早的得到页面。但是考虑到实际的生产过程中我们对于一些页面共享的样式的管理，外部CSS还是不可避免的。当然，我们可以将一些关键的样式嵌入在HTML。</p>
<h4 id="Media-query-on-lt-link"><a href="#Media-query-on-lt-link" class="headerlink" title="Media query on \&lt;link>"></a>Media query on \&lt;link></h4><p>media query 用于对于不同媒体样式的区分，诸如打印，投影之类的(一般不太常见)。但是如果用于响应式网站上，media query 就可以排上大用场。如下面的CSS标签在一般的桌面网站的加载过程中是不会阻塞页面的初次渲染的。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">media</span>=<span class="string">"(max-width: 768px)"</span> <span class="attr">href</span>=<span class="string">"example.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在你访问桌面网站的时候，如果浏览器的宽度大于768px的时候，example.css不会成为关键资源，这样就可以减少关键资源的数量。</p>
<p>注意这里不会影响关键路径，不表示这个不会被下载和解析。它会以一个较低的优先级进行加载和解析。</p>
<h4 id="Async-JavaScript"><a href="#Async-JavaScript" class="headerlink" title="Async JavaScript"></a>Async JavaScript</h4><p>上面说过，不管是 inline JavaScript ，还是类似于这种<code>&lt;script src=&quot;./app.js&quot;&gt;&lt;/script&gt;</code>都会阻塞页面的加载。所以对于JavaScript我们可以用<code>async</code>这个属性将脚本标识为异步的。被标示为<code>async</code>的 script 标签不会阻塞页面的渲染，所以不会加入到关键渲染路径中。他会在脚本文件被下载完成之后被执行，同时会在window的load之前被执行。</p>
<p>但是async会打乱文件执行的顺序，他并不能保证文件按照他在HTML上出现的顺序被执行。</p>
<h4 id="动态-Script-tag"><a href="#动态-Script-tag" class="headerlink" title="动态 Script tag"></a>动态 Script tag</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loadScript = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">  script.src = <span class="string">"script1.js"</span>;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoad'</span>, loadScript);</span><br></pre></td></tr></table></figure>
<p>这里代码很好理解，就是等到DOM构建完成之后我们再去加载这个脚本。这样我们也可以将JavaScript脚本从关键渲染路径当中去除掉</p>
<h4 id="Ajax-动态获取脚本"><a href="#Ajax-动态获取脚本" class="headerlink" title="Ajax 动态获取脚本"></a>Ajax 动态获取脚本</h4><p>其实和上面代码原理一样，只是获取JS的方式从 Script tag 变成了 通过 XMLHttpRequest 来获取</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.open(<span class="string">"get"</span>, <span class="string">"script1.js"</span>, <span class="literal">true</span>);</span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">              <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</span><br><span class="line">              script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">              script.text = xhr.responseText;</span><br><span class="line">              <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从分析了从获取到HTML之后到整个页面的渲染过程之后，我们可以轻而易举的看出那些优化手段的背后的原理基础。也就跟深刻的理解了页面优化手段。当然这个只是整个网站前端优化的一小部分，我们还要从网络层面，服务器层面去优化。这里先埋个坑，下片文章再补。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/10/15/javascript/介绍/" class="prev">上一篇</a><a href="/2016/03/15/javascript/2015-03-15-promise/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://blog.boelroy.com">Boelroy</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-41473417-2",'auto');ga('send','pageview');</script></body></html>